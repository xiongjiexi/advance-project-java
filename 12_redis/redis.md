# redis 主从复制、高可用、集群

## Redis主从复制

### 主从复制主要作用

* 多机热备
* 读写分离
* 负载均衡
* 故障恢复



### 配置主从复制

主从复制是在从节点发起的，不需要主节点做任何事情。

1. 修改从节点配置文件

   配置文件中加入`salveof 127.0.0.1 6500`

2. 先启动主节点，再启动从节点

   启动从节点要指定执行对应修改的配置文件`./redis-server ../redis2.conf`





## Redis Sentinel 高可用

哨兵架构由两部分组成：数据节点、哨兵节点。

数据节点：普通的主从节点，并无区别

哨兵节点：特殊节点，不存储数据



### 部署哨兵节点

三个哨兵节点配置文件除了端口完全相同即可。

配置：

```bash
port 6700
daemonize yes
logfile sentinel-6700.log
sentinel monitor mymaster 127.0.0.1 6379 2
```

`sentinel monitor mymaster 127.0.0.1 6379 2` 表示哨兵监控127.0.0.1:6379主节点，该主节点名称是mymaster；`2`表示至少需要两个哨兵节点同意才能判断主节点故障进行故障转移

启动哨兵：

```
# 两种方式皆可启动哨兵，没区别，调用同一个脚本
redis-sentinel sentinel-6700.conf
redis-server sentinel-6700.conf --sentinel
```

使用redis-cli连接哨兵节点：

```
redis-cli -h 127.0.0.1 -p 6700
```

使用info查看哨兵信息：

```
127.0.0.1:6700> info Sentinel
# Sentinel
sentinel_masters:1  # 哨兵主节点1个
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3 # 数据主节点地址，数据从节点个数，哨兵个数
```

此时查看哨兵节点配置文件，会发现有变化：

```
port 6700
daemonize yes
logfile "sentinel-6700.log"
sentinel monitor mymaster 127.0.0.1 6379 2
# Generated by CONFIG REWRITE
protected-mode no
pidfile "/var/run/redis.pid"
user default on nopass ~* &* +@all
dir "/home/jesse/redis"
sentinel myid 01f804d4c24a122e82183579cbbf2322a92a016e
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
sentinel current-epoch 0
sentinel known-replica mymaster 127.0.0.1 6500
sentinel known-replica mymaster 127.0.0.1 6501
sentinel known-sentinel mymaster 127.0.0.1 6701 3a010f567e4d3ad5c4d9f644c14299a3add0de89
sentinel known-sentinel mymaster 127.0.0.1 6702 6564664c93e086cf79842ba0911654280dec2141
```

从上面能看出数据从节点、哨兵从节点。



### 哨兵的故障转移

当redis数据主节点宕机（kill掉），可以连接哨兵查看info。一开始info没有变化，等一小会哨兵发现主节点故障， 执行故障转移，info中可以看到master节点address变为之前的数据从节点了：

![image-20210721002843487](image-20210721002843487.png)

重启原来主节点，可以发现自动变为了从节点。

哨兵执行故障转移，会改写所有的配置文件。

哨兵可以配置监控多个主节点，配置多个`sentinel monitor`即可。





## Redis Cluster

集群由多个节点组成，数据分布在这些节点中。

集群节点分为主节点、从节点：只有主节点负责读写请求和维护集群信息，从节点只用来同步主节点数据和状态。

### 集群的作用

* 数据分片
    * 突破单节点内存大小限制
    * 每个主节点都可以对外提供读写服务，提高了响应能力
* 高可用
    * 主从复制
    * 主节点故障自动转移



### 启动集群

通常使用脚本来启动，但也可以按照下面步骤手动启动

配置集群节点：

```
#redis-7000.conf
port 7000
cluster-enabled yes
cluster-config-file "node-7000.conf"
logfile "log-7000.log"
dbfilename "dump-7000.rdb"
daemonize yes
```

`cluster-enabled` 表示开启集群模式

`cluster-config-file` 指定集群配置文件的位置。每个集群节点会维护一份集群配置文件，当集群信息发生变化时，节点会更新到配置文件中。当节点启动时，先会读取集群配置文件，如果没有配置文件，则初始化一份集群配置文件。

执行cluster nodes命令查看集群节点情况：

```
$ src/redis-cli -p 7000 cluster nodes
9817df9ac014be0e3325e1b03047e778782db501 :7000@17000 myself,master - 0 0 0 connected
```

第一列代表节点id，重启不会重新生成。

**节点握手**

以同样方式启动多个集群节点，再将它们进行节点握手，组成一个网络。

在7000节点中执行`CLUSTER MEET 192.168.3.29 7001`，即可完成7000节点与7001节点的握手。握手后可再查看集群节点情况。

```
~/redis$ src/redis-cli -p 7000
127.0.0.1:7000> CLUSTER MEET 192.168.3.29 7001
OK
127.0.0.1:7000> CLUSTER MEET 192.168.3.29 7002
OK
127.0.0.1:7000> CLUSTER MEET 192.168.3.29 7003
OK
127.0.0.1:7000> 
~/redis$ src/redis-cli -p 7000 cluster nodes
9817df9ac014be0e3325e1b03047e778782db501 192.168.3.29:7000@17000 myself,master - 0 1626882680000 2 connected
d5330393fabe6cabcfa9a490c3f334cf7ed8c2ee 192.168.3.29:7002@17002 master - 0 1626882681206 0 connected
78a2919c8952e9db4b84fc04439a5b9d5dc869e3 192.168.3.29:7001@17001 master - 0 1626882680201 1 connected
0ddfec297e09e3428801ee1106876fdc19e07886 192.168.3.29:7003@17003 handshake - 0 0 0 disconnected
```

7003是没有启动redis集群节点的，所以显示disconnected。

**分配槽**

集群一共有`16384(0-16383)`个槽，槽是数据管理和迁移的基本单位。将所有槽分配给集群节点之前，集群是下线状态，分配之后，集群将变为上线状态。

分配前可通过`cluster info`查看集群状态：

```
~/redis$ src/redis-cli -p 7000 cluster info
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:3
cluster_size:0
cluster_current_epoch:2
cluster_my_epoch:2
cluster_stats_messages_ping_sent:1522
cluster_stats_messages_pong_sent:1455
cluster_stats_messages_meet_sent:3
cluster_stats_messages_sent:2980
cluster_stats_messages_ping_received:1455
cluster_stats_messages_pong_received:1376
cluster_stats_messages_received:2831
```

集群状态显示fail：`cluster_state:fail`

使用`cluster addslots`命令分配槽：

```
~/redis$ src/redis-cli -p 7000 cluster addslots {0..5461}
OK
~/redis$ src/redis-cli -p 7001 cluster addslots {5462..10922}
OK
~/redis$ src/redis-cli -p 7002 cluster addslots {10923..16383}
OK
```

再查看集群状态：

```
~/redis$ src/redis-cli -p 7000 cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:3
cluster_size:3
cluster_current_epoch:2
cluster_my_epoch:2
cluster_stats_messages_ping_sent:1688
cluster_stats_messages_pong_sent:1632
cluster_stats_messages_meet_sent:3
cluster_stats_messages_sent:3323
cluster_stats_messages_ping_received:1632
cluster_stats_messages_pong_received:1542
cluster_stats_messages_received:3174
```

此时集群就可以对外提供服务了。

**接下来完善集群的高可用：指定主从关系**

通过`cluster replicate`为普通集群从节点指定主节点：

由于从节点没有执行握手，导致报错：

```
~/redis$ src/redis-cli -p 8000 cluster replicate 9817df9ac014be0e3325e1b03047e778782db501
(error) ERR Unknown node 9817df9ac014be0e3325e1b03047e778782db501
```

握手加入集群后，成功配置主从关系：

```
~/redis$ src/redis-cli -p 7000
127.0.0.1:7000> CLUSTER MEET 192.168.3.29 8000
OK
jesse@jesse-shenzhou:~/redis$ ^C
~/redis$ src/redis-cli -p 8000 cluster replicate 9817df9ac014be0e3325e1b03047e778782db501
OK
~/redis$ src/redis-cli -p 7000 cluster nodes
9817df9ac014be0e3325e1b03047e778782db501 192.168.3.29:7000@17000 myself,master - 0 1626885259000 2 connected 0-5461
d5330393fabe6cabcfa9a490c3f334cf7ed8c2ee 192.168.3.29:7002@17002 master - 0 1626885260792 0 connected 10923-16383
2056c500a97e1ad6b68f5fbd91f14da9310d66bd 192.168.3.29:8000@18000 slave 9817df9ac014be0e3325e1b03047e778782db501 0 1626885261796 2 connected
78a2919c8952e9db4b84fc04439a5b9d5dc869e3 192.168.3.29:7001@17001 master - 0 1626885260000 1 connected 5462-10922
```

可以看到8000节点是slave连接状态。